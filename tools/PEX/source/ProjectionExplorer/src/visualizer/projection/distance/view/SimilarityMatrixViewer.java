/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (c) 2005-2007 Universidade de Sao Paulo, Sao Carlos/SP, Brazil.
 * All Rights Reserved.
 *
 * This file is part of Projection Explorer (PEx).
 *
 * How to cite this work:
 *
@inproceedings{paulovich2007pex,
author = {Fernando V. Paulovich and Maria Cristina F. Oliveira and Rosane
Minghim},
title = {The Projection Explorer: A Flexible Tool for Projection-based
Multidimensional Visualization},
booktitle = {SIBGRAPI '07: Proceedings of the XX Brazilian Symposium on
Computer Graphics and Image Processing (SIBGRAPI 2007)},
year = {2007},
isbn = {0-7695-2996-8},
pages = {27--34},
doi = {http://dx.doi.org/10.1109/SIBGRAPI.2007.39},
publisher = {IEEE Computer Society},
address = {Washington, DC, USA},
}
 *
 * PEx is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * PEx is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * This code was developed by members of Computer Graphics and Image
 * Processing Group (http://www.lcad.icmc.usp.br) at Instituto de Ciencias
 * Matematicas e de Computacao - ICMC - (http://www.icmc.usp.br) of
 * Universidade de Sao Paulo, Sao Carlos/SP, Brazil. The initial developer
 * of the original code is Fernando Vieira Paulovich <fpaulovich@gmail.com>.
 *
 * Contributor(s): Rosane Minghim <rminghim@icmc.usp.br>
 *
 * You should have received a copy of the GNU General Public License along
 * with PEx. If not, see <http://www.gnu.org/licenses/>.
 *
 * ***** END LICENSE BLOCK ***** */

package visualizer.projection.distance.view;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseMotionAdapter;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import visualizer.graph.Connectivity;
import visualizer.graph.Graph;
import visualizer.graph.Scalar;
import visualizer.graph.Vertex;
import visualizer.graph.coodination.Coordination;
import visualizer.graph.coodination.Mapping;
import visualizer.graph.listeners.VertexSelectionFactory;
import visualizer.projection.ProjectionViewer;
import visualizer.projection.distance.DistanceMatrix;
import visualizer.topic.Topic;
import visualizer.util.OpenDialog;
import visualizer.util.PExConstants;
import visualizer.util.Pair;
import visualizer.view.JExtendedComboBox;
import visualizer.view.ProjectionExplorerView;
import visualizer.view.Viewer;
import visualizer.view.color.ColorScalePanel;
import visualizer.view.color.ColorScaleType;
import visualizer.view.color.ColorTable;

/**
 *
 * @author Fernando Vieira Paulovich
 */
public class SimilarityMatrixViewer extends Viewer {

    /** Creates new form SimilarityMatrixViewer */
    private SimilarityMatrixViewer(ProjectionExplorerView pexview) {
        super(pexview);

        this.view = new ViewPanel(this.pexview);
        this.coord = new Coordination(pexview.getCoordinator(), this);

        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mapSplitPane = new javax.swing.JSplitPane();
        comboPanel = new javax.swing.JPanel();
        coordLabel = new javax.swing.JLabel();
        coordComboBox = new JExtendedComboBox(this.coordComboModel);
        similarityMatrixPanel = new javax.swing.JPanel();
        titlePanel = new javax.swing.JPanel();
        titleTextField = new javax.swing.JTextField();
        titleComboBox = new JExtendedComboBox(this.titlesComboModel);
        scrollPaneGraph = new javax.swing.JScrollPane(this.view);

        setClosable(true);
        setIconifiable(true);
        setMaximizable(true);
        setResizable(true);
        addInternalFrameListener(new javax.swing.event.InternalFrameListener() {
            public void internalFrameActivated(javax.swing.event.InternalFrameEvent evt) {
                formInternalFrameActivated(evt);
            }
            public void internalFrameClosed(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosing(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeactivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeiconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameIconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameOpened(javax.swing.event.InternalFrameEvent evt) {
            }
        });

        mapSplitPane.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        mapSplitPane.setOneTouchExpandable(true);

        comboPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(""));
        comboPanel.setLayout(new java.awt.GridBagLayout());

        coordLabel.setText("Coordination");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);
        comboPanel.add(coordLabel, gridBagConstraints);

        coordComboBox.setMaximumSize(new java.awt.Dimension(85, 27));
        coordComboBox.setMinimumSize(new java.awt.Dimension(85, 27));
        coordComboBox.setPreferredSize(new java.awt.Dimension(85, 27));
        coordComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                coordComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.insets = new java.awt.Insets(3, 1, 3, 3);
        comboPanel.add(coordComboBox, gridBagConstraints);

        mapSplitPane.setLeftComponent(comboPanel);

        similarityMatrixPanel.setLayout(new java.awt.BorderLayout());

        titlePanel.setBorder(javax.swing.BorderFactory.createTitledBorder(""));
        titlePanel.setLayout(new java.awt.BorderLayout(5, 5));

        titleTextField.setEditable(false);
        titlePanel.add(titleTextField, java.awt.BorderLayout.CENTER);

        titleComboBox.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                titleComboBoxMouseClicked(evt);
            }
        });
        titleComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                titleComboBoxActionPerformed(evt);
            }
        });
        titlePanel.add(titleComboBox, java.awt.BorderLayout.EAST);

        similarityMatrixPanel.add(titlePanel, java.awt.BorderLayout.PAGE_START);
        similarityMatrixPanel.add(scrollPaneGraph, java.awt.BorderLayout.CENTER);

        mapSplitPane.setRightComponent(similarityMatrixPanel);

        getContentPane().add(mapSplitPane, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void coordComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_coordComboBoxActionPerformed
        Mapping mapping = (Mapping) this.coordComboBox.getSelectedItem();

        if (mapping != null && mapping.getName().equals("topic")) {
            if (OpenDialog.checkCorpus(this.graph, this)) {
                this.coord.changeMapping(mapping);
            } else {
                this.coordComboBox.setSelectedItem(Mapping.OFF);
            }
        } else {
            this.coord.changeMapping(mapping);
        }
}//GEN-LAST:event_coordComboBoxActionPerformed

    private void titleComboBoxMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_titleComboBoxMouseClicked
        if (evt.getClickCount() == 2) {
            String title_aux = (String) this.titleComboBox.getSelectedItem();

            if (this.titleComboBox.getItemCount() > 1) {
                this.titlesComboModel.removeElement(title_aux);
                this.titleComboBox.setSelectedIndex(0);
                this.graph.removeTitle(title_aux);
                this.setGraphChanged(true);
            }
        }
}//GEN-LAST:event_titleComboBoxMouseClicked

    private void titleComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_titleComboBoxActionPerformed
        String title_aux = (String) ((JComboBox) evt.getSource()).getSelectedItem();

        if (title != null) {
            if (this.graph != null) {
                this.graph.changeTitle(title_aux);
            }

            this.pexview.refreshLists();
            this.updateImage();
        }
}//GEN-LAST:event_titleComboBoxActionPerformed

    private void formInternalFrameActivated(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_formInternalFrameActivated
        this.pexview.setFocusedJInternalFrame(this);
    }//GEN-LAST:event_formInternalFrameActivated

    @Override
    public void updateScalars(Scalar scalar) {
    }

    @Override
    public void updateConnectivities(Connectivity connectivity) {
    }

    @Override
    public void updateCoordinations(Mapping mapping) {
        this.coordComboModel.removeAllElements();
        this.coordComboModel.addElement(Mapping.OFF);

        for (Mapping m : this.coord.getMappings()) {
            if (this.coordComboModel.getIndexOf(m) < 0) {
                this.coordComboModel.addElement(m);
            }
        }

        if (mapping != null) {
            this.coordComboBox.setSelectedItem(mapping);
            this.prevCoord = mapping;
        }
    }

    @Override
    public void updateTitles(String name) {
        this.titlesComboModel.removeAllElements();
        for (String t : this.graph.getTitles()) {
            this.titlesComboModel.addElement(t);
        }

        if (name != null) {
            this.titleComboBox.setSelectedItem(name);
        }

        this.setGraphChanged(true);
    }

    @Override
    public Connectivity getCurrentConnectivity() {
        return null;
    }

    @Override
    public Scalar getCurrentScalar() {
        return null;
    }

    @Override
    public int getNeighborhoodDepth() {
        return 0;
    }

    @Override
    public void setNeighborhoodDepth(int depth) {
    }

    @Override
    public int saveOnClosing() {
        return javax.swing.JOptionPane.NO_OPTION;
    }

    @Override
    public void zoomIn() {
        this.view.zoom(1.1f);
    }

    @Override
    public void zoomOut() {
        this.view.zoom(0.9091f);
    }

    @Override
    public boolean runForce() {
        return false;
    }

    @Override
    public void cleanTopics() {
    }

    @Override
    public void addTopic(Topic topic) {
    }

    @Override
    public void cleanSelection(boolean cleanVertex) {
        if (this.view != null) {
            this.view.cleanMarkedVertices(cleanVertex);
        }
    }

    @Override
    public void selectVertices(ArrayList<Vertex> vertices) {
        if (this.view != null) {
            this.view.cleanMarkedVertices(false);
            this.view.markVertices(vertices);
        }
    }

    @Override
    public ColorTable getColorTable() {
        if (this.view != null) {
            return this.view.getColorTable();
        }

        return null;
    }

    @Override
    public void updateImage() {
        if (this.view != null) {
            this.view.cleanImage();
            this.view.repaint();
        }
    }

    @Override
    public void colorAs(Scalar scalar) {
    }

    @Override
    public Vertex getSelectedVertex() {
        if (this.view != null) {
            return this.view.getMarkedVertex();
        }

        return null;
    }

    @Override
    public Font getViewerFont() {
        if (this.view != null) {
            return this.view.getFont();
        }

        return null;
    }

    @Override
    public void setViewerFont(Font font) {
        if (this.view != null) {
            this.view.setFont(font);
        }
    }

    @Override
    public void setViewerBackground(Color bg) {
        if (this.view != null) {
            this.view.setBackground(bg);
        }
    }

    @Override
    public void deleteSelectedVertices() {
    }

    @Override
    public void saveToPngImageFile(String filename) throws IOException {
        if (this.view != null) {
            this.view.saveToPngImageFile(filename);
        }
    }

    @Override
    public ArrayList<Vertex> getSelectedVertex(Point source, Point target) {
        if (this.view != null) {
            return this.view.getSelectedVertex(source, target);
        }

        return null;
    }

    @Override
    public Graph getGraph() {
        return this.graph;
    }

    @Override
    public String getCurrentTitle() {
        return (String) this.titleComboBox.getSelectedItem();
    }

    @Override
    public void markNeighbors(Vertex vertex) {
        if (vertex != null) {
            this.view.cleanMarkedVertices(false);
            vertex.setSelected(true);
            this.view.cleanImage();
            this.view.repaint();
        }
    }

    @Override
    public void setTitle(String title) {
        if (!title.startsWith("[")) {
            title = "[" + this.id + "]: " + title;
        }

        super.setTitle(title);
    }

    @Override
    public void setFont(java.awt.Font font) {
        this.font = font;
        this.view.repaint();
    }

    @Override
    public java.awt.Font getFont() {
        return this.font;
    }

    public static SimilarityMatrixViewer getInstance(DistanceMatrix dmat, ProjectionExplorerView pexview) {
        SimilarityMatrixViewer ins = new SimilarityMatrixViewer(pexview);
        ins.dmat = dmat;
        ins.graph = ins.createGraph(dmat);

        ins.view.setPreferredSize(new Dimension((int) (dmat.getElementCount() * 1.5f),
                (int) (dmat.getElementCount() * 1.5f)));
        ins.view.setSize(new Dimension((int) (dmat.getElementCount() * 1.5f),
                (int) (dmat.getElementCount() * 1.5f)));

        ins.updateTitles(null);

        return ins;
    }

    private SimilarityMatrixGraph createGraph(DistanceMatrix dmat) {
        SimilarityMatrixGraph newgraph = new SimilarityMatrixGraph();
        ArrayList<Vertex> vertex = new ArrayList<Vertex>();

        int[] index = createIndex(dmat);
        int titleid = newgraph.addTitle(PExConstants.FNAME);
        Scalar scalar = newgraph.addScalar(PExConstants.CDATA);

        for (int i = 0; i < dmat.getElementCount(); i++) {
            Vertex v = new Vertex(index[i], i, i);
            v.setUrl(dmat.getIds().get(index[i]));
            v.setTitle(titleid, dmat.getIds().get(index[i]));
            v.setScalar(scalar, dmat.getClassData()[index[i]]);
            v.setValid(true);
            vertex.add(v);
        }

        newgraph.setVertex(vertex);

        return newgraph;
    }

//    private int[] createIndex(DistanceMatrix dmat) {
//        int[] index = new int[dmat.getElementCount()];
//
////        //creating the uni-dimensional projection
////        float[] proj = new float[dmat.getElementCount()];
////
////        for (int i = 0; i < proj.length; i++) {
////            proj[i] = dmat.getDistance(0, i) / dmat.getMaxDistance();
////        }
////
////        int nrit = 100;
////        float fracdelta = 8.0f;
////
////        for (int k = 0; k < nrit; k++) {
////            for (int i = 0; i < proj.length; i++) {
////                for (int j = 0; j < proj.length; j++) {
////                    if (i == j) {
////                        continue;
////                    }
////
////                    float dr1 = Math.abs(proj[i] - proj[j]);
////
////                    float drn = dmat.getDistance(i, j);
////                    float normdrn = (drn - dmat.getMinDistance()) /
////                            (dmat.getMaxDistance() - dmat.getMinDistance());
////
////                    float delta = normdrn - dr1;
////                    delta *= Math.abs(delta);
////                    delta /= fracdelta;
////
////                    //moving ins2 -> ins1
////                    proj[j] += delta * ((proj[j] > proj[i]) ? 1 : -1);
////                }
////            }
////        }
//
//        ClassicalScalingProjection mds = new ClassicalScalingProjection();
//        float[][] project = mds.project(dmat, new ProjectionData(), null);
//
//        //creating the uni-dimensional projection
//        float[] proj = new float[project.length];
//
//        for (int i = 0; i < proj.length; i++) {
//            proj[i] = project[i][0];
//        }
//
//        ArrayList<Pair> order = new ArrayList<Pair>();
//
//        for (int i = 0; i < proj.length; i++) {
//            order.add(new Pair(i, proj[i]));
//        }
//
//        Collections.sort(order);
//
//        for (int i = 0; i < proj.length; i++) {
//            index[i] = order.get(i).index;
//        }
//
//        return index;
//    }
    private int[] createIndex(DistanceMatrix dmat) {
        int[] index_aux = new int[dmat.getElementCount()];

        //getting the classes
        float[] cdata = dmat.getClassData();
        ArrayList<Float> classes = new ArrayList<Float>();

        for (int i = 0; i < cdata.length; i++) {
            if (!classes.contains(cdata[i])) {
                classes.add(cdata[i]);
            }
        }

        Collections.sort(classes);

        int n = 0;
        int ini = 0;

        for (int i = 0; i < classes.size(); i++) {
            float klass = classes.get(i);

            for (int j = 0; j < cdata.length; j++) {
                if (cdata[j] == klass) {
                    index_aux[n] = j;
                    n++;
                }
            }

            Pair[] indexes = new Pair[n - ini];
            int pivot = 0;
            float max = Float.NEGATIVE_INFINITY;

            for (int j = 0; j < indexes.length; j++) {
                for (int k = indexes.length - 1; k >= 0; k--) {
                    float distance = dmat.getDistance(index_aux[j + ini],
                            index_aux[k + ini]);

                    if (max < distance) {
                        pivot = j + ini;
                        max = distance;
                    }
                }
            }

            for (int j = 0; j < indexes.length; j++) {
                indexes[j] = new Pair(index_aux[j + ini],
                        dmat.getDistance(index_aux[pivot], index_aux[j + ini]));
            }

            Arrays.sort(indexes);

            for (int j = 0; j < indexes.length; j++) {
                index_aux[j + ini] = indexes[j].index;
            }

            ini = n;
        }

        //oder the classes to put on the right sequence
        ArrayList<Order> order_aux = new ArrayList<Order>();

        Order ord1 = new Order();
        ord1.begin = 0;
        ord1.end = 0;
        ord1.value = 0.0f;
        order_aux.add(ord1);

        for (int j = ord1.begin + 1; j < index_aux.length; j++) {
            if (cdata[index_aux[ord1.begin]] != cdata[index_aux[j]]) {
                ord1.end = j - 1;
                break;
            }
        }

        Order prev_aux = ord1;

        while (prev_aux.end < index_aux.length - 1) {
            Order new_ord = new Order();
            new_ord.begin = prev_aux.end + 1;
            new_ord.end = prev_aux.end + 1;
            new_ord.value = 0.0f;
            order_aux.add(new_ord);

            for (int j = new_ord.begin + 1; j < index_aux.length; j++) {
                if (cdata[index_aux[new_ord.begin]] != cdata[index_aux[j]]
                        || j == index_aux.length - 1) {
                    new_ord.end = j - 1;

                    if (j == index_aux.length - 1) {
                        new_ord.end = j;
                    }

                    new_ord.value = dmat.getDistance(index_aux[ord1.end],
                            index_aux[new_ord.begin]);

                    break;
                }
            }

            prev_aux = new_ord;
        }

        Collections.sort(order_aux);

        int[] index = new int[index_aux.length];
        int k = 0;

        for (int i = 0; i < order_aux.size(); i++) {
            Order ord2 = order_aux.get(i);

            for (int j = ord2.begin; j <= ord2.end; j++, k++) {
                index[k] = index_aux[j];
            }
        }

        return index;
    }

    public class ViewPanel extends JPanel {

        public ViewPanel(ProjectionExplorerView pexview) {
            this.pexview = pexview;

            this.colorTable = new ColorTable();
            this.colorTable.setColorScaleType(ColorScaleType.LINEARGRAYSCALE);
            this.colorTable.getColorScale().setMin(0.25f);
            this.colorTable.getColorScale().setReverse(true);
            this.csp = new ColorScalePanel(SimilarityMatrixViewer.this);
            this.csp.setColorTable(this.colorTable);
            this.csp.setPreferredSize(new Dimension(200, 12));
            this.add(this.csp);

            this.setBackground(java.awt.Color.WHITE);
            this.addMouseMotionListener(new MouseMotionListener());
            this.addMouseListener(new MouseClickedListener());

            this.setLayout(new FlowLayout(FlowLayout.LEFT));
        }

        @Override
        public void paintComponent(java.awt.Graphics g) {
            super.paintComponent(g);

            java.awt.Graphics2D g2 = (java.awt.Graphics2D) g;

            if (this.origimage == null) {
                int size = dmat.getElementCount();
                int cBorder = dmat.getElementCount() / 50;

                this.origimage = new BufferedImage(cBorder + size, cBorder + size,
                        BufferedImage.TYPE_INT_RGB);

                java.awt.Graphics2D g2Buffer = this.origimage.createGraphics();
                g2Buffer.setColor(this.getBackground());

                createImage(g2Buffer);
                g2Buffer.dispose();
            }

            if (this.redimage == null) {
                int size = (int) (this.origimage.getHeight() * this.zoomfactor);
                this.redimage = this.origimage.getScaledInstance(size, size, 0);
            }

            if (this.redimage != null) {
                g2.drawImage(this.redimage, ViewPanel.SPACE, ViewPanel.SPACE, null);
            }

            //Draw he rectangle to select the points
            if (this.source != null && this.target != null) {
                int x = this.source.x;
                int width = width = this.target.x - this.source.x;

                int y = this.source.y;
                int height = this.target.y - this.source.y;

                if (this.source.x > this.target.x) {
                    x = this.target.x;
                    width = this.source.x - this.target.x;
                }

                if (this.source.y > this.target.y) {
                    y = this.target.y;
                    height = this.source.y - this.target.y;
                }

                g2.setColor(this.color);
                g2.drawRect(x, y, width, height);

                g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, 0.45f));
                g2.setPaint(this.color);
                g2.fill(new java.awt.Rectangle(x, y, width, height));
            } else {
                //Draw the vertex tool tip
                if (vertexLabelVisible && this.toolTipLabel != null && this.toolTipPosition != null) {
                    //Getting the font information
                    g2.setFont(this.getFont());
                    java.awt.FontMetrics metrics = g2.getFontMetrics(g2.getFont());

                    //Getting the label size
                    int width = metrics.stringWidth(this.toolTipLabel);
                    int height = metrics.getAscent();

                    g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, 0.75f));
                    g2.setPaint(java.awt.Color.WHITE);
                    g2.fill(new java.awt.Rectangle(this.toolTipPosition.x - 2,
                            this.toolTipPosition.y - height, width + 4, height + 4));
                    g2.setComposite(java.awt.AlphaComposite.getInstance(java.awt.AlphaComposite.SRC_OVER, 1.0f));

                    g2.setColor(java.awt.Color.DARK_GRAY);
                    g2.drawRect(this.toolTipPosition.x - 2, this.toolTipPosition.y - height, width + 4, height + 4);

                    //Drawing the label
                    g2.drawString(this.toolTipLabel, this.toolTipPosition.x, this.toolTipPosition.y);
                }
            }
        }

        private void createImage(java.awt.Graphics2D g2Buffer) {
            int size = dmat.getElementCount();
            int cBorder = dmat.getElementCount() / 50;

            //the color table used to draw the matrix
            ColorTable selectedColorTable = new ColorTable(ColorScaleType.HEATEDOBJECTS);
            selectedColorTable.getColorScale().setMax(0.9f);
            selectedColorTable.getColorScale().setMin(0.25f);

            ArrayList<Vertex> vertex = graph.getVertex();

            for (int i = 0; i < vertex.size(); i++) {
                Vertex v1 = vertex.get(i);

                for (int j = 0; j < vertex.size(); j++) {
                    Vertex v2 = vertex.get(j);

                    float colorvalue = 0.0f;

                    if (i != j) {
                        colorvalue = (dmat.getDistance((int) v1.getId(), (int) v2.getId()) - dmat.getMinDistance())
                                / (dmat.getMaxDistance() - dmat.getMinDistance());
                    }

                    if (v1.isSelected() || v2.isSelected()) {
                        origimage.setRGB(cBorder + i, j, selectedColorTable.getColor(colorvalue).getRGB());
                    } else {
                        origimage.setRGB(cBorder + i, j, colorTable.getColor(1.0f - colorvalue).getRGB());
                    }
                }
            }

            //draw the class color legend
            float[] cdata = dmat.getClassData();
            float min = Float.POSITIVE_INFINITY;
            float max = Float.NEGATIVE_INFINITY;

            for (int i = 0; i < cdata.length; i++) {
                if (min > cdata[i]) {
                    min = cdata[i];
                }

                if (max < cdata[i]) {
                    max = cdata[i];
                }
            }

            ColorTable legendColorTable = new ColorTable(ColorScaleType.PSEUDORAINBOWCALE);

            for (int i = 0; i < vertex.size(); i++) {
                Vertex v = vertex.get(i);

                float colorvalue = (cdata[(int) v.getId()] - min) / (max - min);
                g2Buffer.setColor(legendColorTable.getColor(colorvalue));

                g2Buffer.fillRect(0, i, cBorder, i + 1);
                g2Buffer.fillRect(i + cBorder, size, i + 1 + cBorder, size + cBorder);
            }

            g2Buffer.setColor(Color.WHITE);
            g2Buffer.fillRect(0, size, cBorder, size + cBorder);

            g2Buffer.dispose();
        }

        public void zoom(float factor) {
            this.zoomfactor *= factor;
            this.cleanImage();
            this.repaint();
        }

        public void saveToPngImageFile(String filename) throws IOException {
            try {
                int space = redimage.getWidth(null) / 20;
                BufferedImage image = new BufferedImage(redimage.getWidth(null) + 3 * space,
                        redimage.getHeight(null) + 3 * space, BufferedImage.TYPE_INT_RGB);
                this.paint(image.getGraphics());
                ImageIO.write(image, "png", new File(filename));
            } catch (IOException ex) {
                Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);
            }
        }

        public Vertex getMarkedVertex() {
            return markedVertex;
        }

        public void cleanImage() {
            this.origimage = null;
            this.redimage = null;
        }

        public ColorTable getColorTable() {
            return colorTable;
        }

        public void markVertices(ArrayList<Vertex> vertices) {
            if (vertices != null) {
                this.cleanMarkedVertices(false);

                //change the vertices' colors
                for (Vertex v : vertices) {
                    v.setSelected(true);
                }

                this.cleanImage();
                this.repaint();
            }
        }

        public void cleanMarkedVertices(boolean cleanVertex) {
            if (graph != null) {
                this.markedVertex = null;

                for (Vertex vertex : graph.getVertex()) {
                    vertex.setSelected(false);
                }
            }

            this.cleanImage();
            this.repaint();
        }

        @Override
        public void setFont(java.awt.Font font) {
            SimilarityMatrixViewer.this.setFont(font);
        }

        @Override
        public java.awt.Font getFont() {
            return SimilarityMatrixViewer.this.getFont();
        }

        @Override
        public void setBackground(Color bg) {
            super.setBackground(bg);
            if (this.csp != null) {
                this.csp.setBackground(bg);
            }
        }

        public ArrayList<Vertex> getSelectedVertex(java.awt.Point localSource,
                java.awt.Point localTarget) {
            int cBorder = dmat.getElementCount() / 50;

            ArrayList<Vertex> selVertex = new ArrayList<Vertex>();

            if (graph != null) {
                int x = localSource.x;
                int width = localTarget.x - localSource.x;

                int y = localSource.y;
                int height = localTarget.y - localSource.y;

                if (localSource.x > localTarget.x) {
                    x = localTarget.x;
                    width = localSource.x - localTarget.x;
                }

                if (localSource.y > localTarget.y) {
                    y = localTarget.y;
                    height = localSource.y - localTarget.y;
                }

                width += cBorder * zoomfactor;
                height += cBorder * zoomfactor;

                for (Vertex v : graph.getVertex()) {
                    int vx = (int) ((v.getX() + cBorder) * zoomfactor) + ViewPanel.SPACE;
                    int vy = (int) ((v.getY() + cBorder) * zoomfactor) + ViewPanel.SPACE;

                    if ((vx >= x && vx <= x + width) && (vy >= y && vy <= y + height)) {
                        selVertex.add(v);
                    }
                }
            }

            return selVertex;
        }

        class MouseMotionListener extends MouseMotionAdapter {

            @Override
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                super.mouseMoved(evt);

                if (graph != null) {
                    int cBorder = dmat.getElementCount() / 50;
                    int vx = (int) ((evt.getX() - cBorder) / zoomfactor) - ViewPanel.SPACE;
                    int vy = (int) (evt.getY() / zoomfactor) - ViewPanel.SPACE;
                    ArrayList<Vertex> vertices = graph.getVerticesByPosition(vx, vy);

                    if (vertices.size() > 0) {
                        ViewPanel.this.toolTipLabel = "";
                        for (int i = 0; i < vertices.size(); i++) {
                            ViewPanel.this.toolTipLabel += vertices.get(i).toString();

                            if (i < vertices.size() - 1) {
                                ViewPanel.this.toolTipLabel += " <> ";
                            }
                        }

                        if (ViewPanel.this.toolTipLabel.trim().length() > 0) {
                            if (ViewPanel.this.toolTipLabel.length() > 100) {
                                ViewPanel.this.toolTipLabel = ViewPanel.this.toolTipLabel.substring(0, 96) + "...";
                            }
                            ViewPanel.this.toolTipPosition = evt.getPoint();
                            ViewPanel.this.repaint();
                        }

                        titleTextField.setText(ViewPanel.this.toolTipLabel);
                        titleTextField.setCaretPosition(0);
                    } else {
                        //Clear the tool tip
                        titleTextField.setText("");
                        ViewPanel.this.toolTipLabel = null;
                        ViewPanel.this.toolTipPosition = null;
                        ViewPanel.this.repaint();
                    }
                }
            }

            @Override
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                if (source != null) {
                    target = evt.getPoint();
                }

                repaint();
            }

        }

        class MouseClickedListener extends MouseAdapter {

            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                super.mouseClicked(evt);

                if (graph != null) {
                    if (evt.getButton() == java.awt.event.MouseEvent.BUTTON3) {
                        cleanMarkedVertices(true);
                    } else {
                        int cBorder = dmat.getElementCount() / 50;
                        int vx = (int) ((evt.getX() - cBorder) / zoomfactor) - ViewPanel.SPACE;
                        int vy = (int) (evt.getY() / zoomfactor) - ViewPanel.SPACE;
                        ArrayList<Vertex> vertices = graph.getVerticesByPosition(vx, vy);

                        if (vertices.size() > 0) {
                            ViewPanel.this.cleanMarkedVertices(false);

                            for (Vertex v : vertices) {
                                v.setSelected(true);
                            }

                            cleanImage();
                            repaint();
                        }
                    }
                }
            }

            @Override
            public void mousePressed(java.awt.event.MouseEvent evt) {
                super.mousePressed(evt);

                if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1) {
                    if (graph != null) {
                        source = evt.getPoint();
                        color = VertexSelectionFactory.getInstance(SimilarityMatrixViewer.this,
                                ProjectionViewer.type).getColor();
                    }
                }
            }

            @Override
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                super.mouseReleased(evt);

                if (graph != null) {
                    if (source != null && target != null) {
                        ArrayList<Vertex> vertices = getSelectedVertex(source, target);

                        if (vertices != null) {
                            setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                            cleanMarkedVertices(false);

                            VertexSelectionFactory.getInstance(SimilarityMatrixViewer.this,
                                    ProjectionViewer.type).vertexSelected(null, vertices);

                            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                        }
                    }
                }

                if (selectedVertex != null) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                }

                selectedVertex = null;
                source = null;
                target = null;
                repaint();
            }

        }
        //Used to select points with the retangle

        private java.awt.Point source = null;
        private java.awt.Point target = null;
        private java.awt.Color color = java.awt.Color.RED;
        //Used to color based on a document
        private Vertex markedVertex;
        //Used to move the points
        private Vertex selectedVertex;
        //Used to show the vertex tool tip
        private String toolTipLabel;
        private java.awt.Point toolTipPosition;
        //The image which will be drawn as a graph
        private float zoomfactor = 1.0f;
        private Image redimage;
        private BufferedImage origimage;
        //Font used to create the label
        private ProjectionExplorerView pexview;
        private ColorScalePanel csp;
        private ColorTable colorTable;
        private static final int SPACE = 30;
    }

    class Order implements Comparable {

        @Override
        public int compareTo(Object o) {
            if (o instanceof Order) {
                if (Math.abs(this.value - ((Order) o).value) == EPSILON) {
                    return 0;
                } else if (this.value - ((Order) o).value > EPSILON) {
                    return 1;
                } else {
                    return -1;
                }
            } else {
                return -1;
            }
        }

        public static final float EPSILON = 0.00001f;
        public int begin;
        public int end;
        public float value;
    }

    private DefaultComboBoxModel coordComboModel = new DefaultComboBoxModel();
    private DefaultComboBoxModel titlesComboModel = new DefaultComboBoxModel();
    private java.awt.Font font = new java.awt.Font("Verdana", java.awt.Font.BOLD, 13);
    private ViewPanel view;
    private SimilarityMatrixGraph graph;
    private DistanceMatrix dmat;
    private Mapping prevCoord = Mapping.OFF;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel comboPanel;
    private javax.swing.JComboBox coordComboBox;
    private javax.swing.JLabel coordLabel;
    private javax.swing.JSplitPane mapSplitPane;
    private javax.swing.JScrollPane scrollPaneGraph;
    private javax.swing.JPanel similarityMatrixPanel;
    private javax.swing.JComboBox titleComboBox;
    private javax.swing.JPanel titlePanel;
    private javax.swing.JTextField titleTextField;
    // End of variables declaration//GEN-END:variables
}
